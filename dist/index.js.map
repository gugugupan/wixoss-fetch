{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/tar-js/lib/header.js","node_modules/tar-js/lib/tar.js","node_modules/tar-js/lib/utils.js","src/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\t\n/*\nstruct posix_header {             // byte offset\n\tchar name[100];               //   0\n\tchar mode[8];                 // 100\n\tchar uid[8];                  // 108\n\tchar gid[8];                  // 116\n\tchar size[12];                // 124\n\tchar mtime[12];               // 136\n\tchar chksum[8];               // 148\n\tchar typeflag;                // 156\n\tchar linkname[100];           // 157\n\tchar magic[6];                // 257\n\tchar version[2];              // 263\n\tchar uname[32];               // 265\n\tchar gname[32];               // 297\n\tchar devmajor[8];             // 329\n\tchar devminor[8];             // 337\n\tchar prefix[155];             // 345\n                                  // 500\n};\n*/\n\n\tvar utils = require(\"./utils\"),\n\t\theaderFormat;\n\t\n\theaderFormat = [\n\t\t{\n\t\t\t'field': 'fileName',\n\t\t\t'length': 100\n\t\t},\n\t\t{\n\t\t\t'field': 'fileMode',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'uid',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'gid',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'fileSize',\n\t\t\t'length': 12\n\t\t},\n\t\t{\n\t\t\t'field': 'mtime',\n\t\t\t'length': 12\n\t\t},\n\t\t{\n\t\t\t'field': 'checksum',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'type',\n\t\t\t'length': 1\n\t\t},\n\t\t{\n\t\t\t'field': 'linkName',\n\t\t\t'length': 100\n\t\t},\n\t\t{\n\t\t\t'field': 'ustar',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'owner',\n\t\t\t'length': 32\n\t\t},\n\t\t{\n\t\t\t'field': 'group',\n\t\t\t'length': 32\n\t\t},\n\t\t{\n\t\t\t'field': 'majorNumber',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'minorNumber',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'filenamePrefix',\n\t\t\t'length': 155\n\t\t},\n\t\t{\n\t\t\t'field': 'padding',\n\t\t\t'length': 12\n\t\t}\n\t];\n\n\tfunction formatHeader(data, cb) {\n\t\tvar buffer = utils.clean(512),\n\t\t\toffset = 0;\n\n\t\theaderFormat.forEach(function (value) {\n\t\t\tvar str = data[value.field] || \"\",\n\t\t\t\ti, length;\n\n\t\t\tfor (i = 0, length = str.length; i < length; i += 1) {\n\t\t\t\tbuffer[offset] = str.charCodeAt(i);\n\t\t\t\toffset += 1;\n\t\t\t}\n\n\t\t\toffset += value.length - i; // space it out with nulls\n\t\t});\n\n\t\tif (typeof cb === 'function') {\n\t\t\treturn cb(buffer, offset);\n\t\t}\n\t\treturn buffer;\n\t}\n\t\n\tmodule.exports.structure = headerFormat;\n\tmodule.exports.format = formatHeader;\n}());\n","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\n\tvar header = require(\"./header\"),\n\t\tutils = require(\"./utils\"),\n\t\trecordSize = 512,\n\t\tblockSize;\n\t\n\tfunction Tar(recordsPerBlock) {\n\t\tthis.written = 0;\n\t\tblockSize = (recordsPerBlock || 20) * recordSize;\n\t\tthis.out = utils.clean(blockSize);\n\t}\n\n\tTar.prototype.append = function (filepath, input, opts, callback) {\n\t\tvar data,\n\t\t\tchecksum,\n\t\t\tmode,\n\t\t\tmtime,\n\t\t\tuid,\n\t\t\tgid,\n\t\t\theaderArr;\n\n\t\tif (typeof input === 'string') {\n\t\t\tinput = utils.stringToUint8(input);\n\t\t} else if (input.constructor !== Uint8Array.prototype.constructor) {\n\t\t\tthrow 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/)[1];\n\t\t}\n\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\topts = opts || {};\n\n\t\tmode = opts.mode || parseInt('777', 8) & 0xfff;\n\t\tmtime = opts.mtime || Math.floor(+new Date() / 1000);\n\t\tuid = opts.uid || 0;\n\t\tgid = opts.gid || 0;\n\n\t\tdata = {\n\t\t\tfileName: filepath,\n\t\t\tfileMode: utils.pad(mode, 7),\n\t\t\tuid: utils.pad(uid, 7),\n\t\t\tgid: utils.pad(gid, 7),\n\t\t\tfileSize: utils.pad(input.length, 11),\n\t\t\tmtime: utils.pad(mtime, 11),\n\t\t\tchecksum: '        ',\n\t\t\ttype: '0', // just a file\n\t\t\tustar: 'ustar  ',\n\t\t\towner: opts.owner || '',\n\t\t\tgroup: opts.group || ''\n\t\t};\n\n\t\t// calculate the checksum\n\t\tchecksum = 0;\n\t\tObject.keys(data).forEach(function (key) {\n\t\t\tvar i, value = data[key], length;\n\n\t\t\tfor (i = 0, length = value.length; i < length; i += 1) {\n\t\t\t\tchecksum += value.charCodeAt(i);\n\t\t\t}\n\t\t});\n\n\t\tdata.checksum = utils.pad(checksum, 6) + \"\\u0000 \";\n\n\t\theaderArr = header.format(data);\n\n\t\tvar i, offset, length;\n\n\t\tthis.out.set(headerArr, this.written);\n\n\t\tthis.written += headerArr.length;\n\n\t\t// If there is not enough space in this.out, we need to expand it to\n\t\t// fit the new input.\n\t\tif (this.written + input.length > this.out.length) {\n\t\t\tthis.out = utils.extend(this.out, this.written, input.length, blockSize);\n\t\t}\n\n\t\tthis.out.set(input, this.written);\n\n\t\t// to the nearest multiple of recordSize\n\t\tthis.written += input.length + (recordSize - (input.length % recordSize || recordSize));\n\n\t\t// make sure there's at least 2 empty records worth of extra space\n\t\tif (this.out.length - this.written < recordSize * 2) {\n\t\t\tthis.out = utils.extend(this.out, this.written, recordSize * 2, blockSize);\n\t\t}\n\n\t\tif (typeof callback === 'function') {\n\t\t\tcallback(this.out);\n\t\t}\n\n\t\treturn this.out;\n\t};\n\n\tTar.prototype.clear = function () {\n\t\tthis.written = 0;\n\t\tthis.out = utils.clean(blockSize);\n\t};\n\n  Tar.utils = utils;\n\n\tTar.stringToUint8 = utils.stringToUint8;\n\tTar.uint8ToBase64 = utils.uint8ToBase64;\n  Tar.base64ToUint8 = utils.base64ToUint8;\n\t\n\tmodule.exports = Tar;\n}());\n","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\n\tvar lookup = [\n\t\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n\t\t\t'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n\t\t\t'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n\t\t\t'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n\t\t\t'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n\t\t\t'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n\t\t\t'w', 'x', 'y', 'z', '0', '1', '2', '3',\n\t\t\t'4', '5', '6', '7', '8', '9', '+', '/'\n\t\t];\n\tfunction clean(length) {\n\t\tvar i, buffer = new Uint8Array(length);\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tbuffer[i] = 0;\n\t\t}\n\t\treturn buffer;\n\t}\n\n\tfunction extend(orig, length, addLength, multipleOf) {\n\t\tvar newSize = length + addLength,\n\t\t\tbuffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);\n\n\t\tbuffer.set(orig);\n\n\t\treturn buffer;\n\t}\n\n\tfunction pad(num, bytes, base) {\n\t\tnum = num.toString(base || 8);\n\t\treturn \"000000000000\".substr(num.length + 12 - bytes) + num;\n\t}\t\n\t\n\tfunction stringToUint8 (input, out, offset) {\n\t\tvar i, length;\n\n\t\tout = out || clean(input.length);\n\n\t\toffset = offset || 0;\n\t\tfor (i = 0, length = input.length; i < length; i += 1) {\n\t\t\tout[offset] = input.charCodeAt(i);\n\t\t\toffset += 1;\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// this prevents an ERR_INVALID_URL in Chrome (Firefox okay)\n\t\tswitch (output.length % 4) {\n\t\t\tcase 1:\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tfunction base64ToUint8(input) {\n\t\tvar base64 = input.match(/^([^=]+)/)[1],\n\t\t\textraBytes = input.match(/(=*)$/)[1].length,\n\t\t\ti = 0, length = base64.length, temp, offset = 0,\n\t\t\tret = clean(base64.length * .75 + extraBytes);\n\n\t\twhile (i < length) {\n\t\t\ttemp = 0;\n\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 18;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 12;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 6;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A');\n\t\t\ti += 1;\n\n\t\t\tret[offset] = temp >> 16 & 0xFF;\n\t\t\toffset += 1;\n\t\t\tret[offset] = temp >> 8 & 0xFF;\n\t\t\toffset += 1;\n\t\t\tret[offset] = temp & 0xFF;\n\t\t\toffset += 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tmodule.exports.clean = clean;\n\tmodule.exports.pad = pad;\n\tmodule.exports.extend = extend;\n\tmodule.exports.stringToUint8 = stringToUint8;\n\tmodule.exports.uint8ToBase64 = uint8ToBase64;\n\tmodule.exports.base64ToUint8 = base64ToUint8;\n}());\n","'use strict'\n\nconst domain = 'www.takaratomy.co.jp'\nconst Tar = require('tar-js')\n\n/* utils */\nconst toArr = obj => {\n  if (!obj) return []\n  if (typeof obj === 'string') return []\n  return Array.prototype.slice.call(obj,0)\n}\nconst $fetch = (...arg) => {\n  return fetch(arg).then(res => {\n    if (res.ok) return res\n    return Promise.reject(res)\n  })\n}\nconst stringToUint8 = str => {\n  return (new TextEncoder()).encode(str)\n}\n\n/* parser */\nfunction toCardType(str) {\n  let map = {\n    'ルリグ': 'LRIG',\n    'アーツ': 'ARTS',\n    'シグニ': 'SIGNI',\n    'スペル': 'SPELL',\n  }\n  return map[str] || str\n}\nfunction toColor(str) {\n  let map = {\n    '白': 'WHITE',\n    '黒': 'BLACK',\n    '赤': 'RED',\n    '青': 'BLUE',\n    '緑': 'GREEN',\n    '無': 'COLORLESS',\n  }\n  return map[str] || str\n}\nfunction toCardText(el) {\n  let text = toArr(el.childNodes).map(node => {\n    if (node.nodeType === node.TEXT_NODE) {\n      return node.nodeValue.replace(/^\\s+/,'').replace(/\\s+$/,'')\n    }\n    if (node.nodeName === 'IMG') {\n      return node.alt\n    }\n    if (node.nodeName === 'BR') {\n      return '\\n'\n    }\n    return node.textContent\n  }).join('')\n  return text\n}\nfunction toFaq(el) {\n  let faq = {}\n  faq.q = el.querySelector('.card_ruleFAQ_q').textContent.replace(/^\\s+/,'').replace(/\\s+$/,'')\n  faq.a = el.querySelector('.card_ruleFAQ_a').textContent.replace(/^\\s+/,'').replace(/\\s+$/,'')\n  return faq\n}\n\n\nfunction toInfo(doc, id) {\n  let info = {}\n  info.pid = id || doc.querySelector('.card_detail_title > p').textContent\n  info.timestamp = Date.now()\n  info.wxid = doc.querySelector('.card_detail_title > p').textContent\n  info.name = doc.querySelector('.card_detail_title > h3').firstChild.textContent\n  info.kana = doc.querySelector('.card_detail_kana').textContent.slice(1,-1)\n  info.rarity = doc.querySelector('.card_rarity').textContent.replace(/\\s/g,'')\n\n  let trs = doc.querySelectorAll('.card_date_box tr')\n  // info.cardType = toCardType(trs[0].children[1].textContent)\n  info.cardType = trs[0].children[1].textContent\n  info.class = trs[0].children[3].textContent\n  // info.color = toColor(trs[1].children[1].textContent)\n  info.color = trs[1].children[1].textContent\n  info.level = trs[1].children[3].textContent\n  info.growCost = trs[2].children[1].textContent\n  info.cost = trs[2].children[3].textContent\n  info.limit = trs[3].children[1].textContent\n  info.power = trs[3].children[3].textContent\n  info.limiting = trs[4].children[1].textContent\n\n  // guard, limiting or coin\n  let key = trs[4].children[2].textContent\n  let value = trs[4].children[3].textContent\n  if (key === 'ガード') {\n    info.guard = value\n    info.timing = '-'\n  } else if (key === '使用タイミング') {\n    info.guard = '-'\n    info.timing = value\n  } else if (key === 'コイン') {\n    info.guard = '-'\n    info.timing = '-'\n    info.coin = value\n  } else {\n    console.warn(`${info.pid}: unknown key \"${key}\"!`)\n  }\n\n  let el = doc.querySelector('.card_skill')\n  info.cardSkill = el? toCardText(el) : ''\n\n  info.cardTexts = toArr(doc.querySelectorAll('.card_text:not(.card_skill)')).map(toCardText)\n\n  // info.imgUrl = domain + doc.querySelector('.card_img > img').getAttribute('src')\n  info.imgUrl = doc.querySelector('.card_img > img').getAttribute('src')\n  info.illust = (doc.querySelector('.card_img').textContent.match(/Illust (.*)$/) || [])[1] || ''\n  if (!info.illust) console.warn(`${info.pid}: no illust!`)\n\n  info.faqs = toArr(doc.querySelectorAll('.card_FAQ > p')).map(toFaq)\n\n  return info\n}\n\n/* fetch */\nfunction fetchById (tar, i) {\n  let url = `http://${domain}/products/wixoss/card/card_detail.php?card_id=${i}`\n  return fetchByUrl(tar, url, i)\n}\n\nfunction fetchByWXId(tar, wx_id) {\n  let url = `http://${domain}/products/wixoss/card/card_list.php?card=card_detail&card_no=${wx_id}`\n  return fetchByUrl(tar, url, undefined)\n}\n\nfunction fetchByUrl(tar, url, i) {\n  return $fetch(url)\n  .then(res => res.text())\n  .then(html => {\n    let dom = (new DOMParser()).parseFromString(html,'text/html')\n    if (!dom) throw 'Failed to parse DOM!'\n\n    // json\n    let info = toInfo(dom, i)\n    let json = JSON.stringify(info, null, '\\t')\n    let name = ('000' + i).slice(-4) + '_' + info.wxid\n    tar.append(`${name}.json`, stringToUint8(json))\n    console.log(`${name}.json done!`)\n\n    // html\n    html = html.replace('<head>','<head>\\r\\n<base href=\"http://www.takaratomy.co.jp/\" />')\n    tar.append(`${name}.html`, stringToUint8(html))\n    console.log(`${name}.html done!`)\n\n    // image\n    return $fetch(info.imgUrl)\n    .then(res => res.arrayBuffer())\n    .then(buffer => {\n      tar.append(`${name}.jpg`, new Uint8Array(buffer))\n      console.log(`${name}.jpg done!`)\n    })\n  })\n}\n\nfunction fetchRange(min, max) {\n  let tar = new Tar()\n  let promises = []\n  for (let i = min; i <= max; i++) {\n    promises.push(fetchById(tar, i))\n  }\n  return Promise.all(promises)\n  .then(() => {\n    let name = ('000' + min).slice(-4) + '-' + ('000' + max).slice(-4)\n    downloadTar(tar, name)\n  })\n}\n\n// fetchWXBox(\"WDK02\", 1, 20)\nfunction fetchWXBox(prefix, min, max) {\n  let tar = new Tar()\n  let promises = []\n  for (let i = min; i <= max; i ++) {\n    const wx_id = `${prefix}-${('00' + i).slice(-3)}`;\n    promises.push(fetchByWXId(tar, wx_id))\n  }\n  return Promise.all(promises)\n  .then(() => {\n    let name = ('000' + min).slice(-4) + '-' + ('000' + max).slice(-4)\n    downloadTar(tar, name)\n  })\n}\n\nfunction downloadTar(tar, name) {\n  let blob = new Blob([tar.out], { type: 'application/octet-stream' })\n  let url = URL.createObjectURL(blob)\n  let link = document.createElement('a')\n  link.href = url\n  link.download = `${name}.tar`\n  link.click()\n}\n\nwindow.fetchRange = fetchRange\nwindow.fetchWXBox = fetchWXBox\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvdGFyLWpzL2xpYi9oZWFkZXIuanMiLCJub2RlX21vZHVsZXMvdGFyLWpzL2xpYi90YXIuanMiLCJub2RlX21vZHVsZXMvdGFyLWpzL2xpYi91dGlscy5qcyIsInNyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qXG4gKiB0YXItanNcbiAqIE1JVCAoYykgMjAxMSBULiBKYW1lc29uIExpdHRsZVxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcbi8qXG5zdHJ1Y3QgcG9zaXhfaGVhZGVyIHsgICAgICAgICAgICAgLy8gYnl0ZSBvZmZzZXRcblx0Y2hhciBuYW1lWzEwMF07ICAgICAgICAgICAgICAgLy8gICAwXG5cdGNoYXIgbW9kZVs4XTsgICAgICAgICAgICAgICAgIC8vIDEwMFxuXHRjaGFyIHVpZFs4XTsgICAgICAgICAgICAgICAgICAvLyAxMDhcblx0Y2hhciBnaWRbOF07ICAgICAgICAgICAgICAgICAgLy8gMTE2XG5cdGNoYXIgc2l6ZVsxMl07ICAgICAgICAgICAgICAgIC8vIDEyNFxuXHRjaGFyIG10aW1lWzEyXTsgICAgICAgICAgICAgICAvLyAxMzZcblx0Y2hhciBjaGtzdW1bOF07ICAgICAgICAgICAgICAgLy8gMTQ4XG5cdGNoYXIgdHlwZWZsYWc7ICAgICAgICAgICAgICAgIC8vIDE1NlxuXHRjaGFyIGxpbmtuYW1lWzEwMF07ICAgICAgICAgICAvLyAxNTdcblx0Y2hhciBtYWdpY1s2XTsgICAgICAgICAgICAgICAgLy8gMjU3XG5cdGNoYXIgdmVyc2lvblsyXTsgICAgICAgICAgICAgIC8vIDI2M1xuXHRjaGFyIHVuYW1lWzMyXTsgICAgICAgICAgICAgICAvLyAyNjVcblx0Y2hhciBnbmFtZVszMl07ICAgICAgICAgICAgICAgLy8gMjk3XG5cdGNoYXIgZGV2bWFqb3JbOF07ICAgICAgICAgICAgIC8vIDMyOVxuXHRjaGFyIGRldm1pbm9yWzhdOyAgICAgICAgICAgICAvLyAzMzdcblx0Y2hhciBwcmVmaXhbMTU1XTsgICAgICAgICAgICAgLy8gMzQ1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNTAwXG59O1xuKi9cblxuXHR2YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKSxcblx0XHRoZWFkZXJGb3JtYXQ7XG5cdFxuXHRoZWFkZXJGb3JtYXQgPSBbXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2ZpbGVOYW1lJyxcblx0XHRcdCdsZW5ndGgnOiAxMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdCdmaWVsZCc6ICdmaWxlTW9kZScsXG5cdFx0XHQnbGVuZ3RoJzogOFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ3VpZCcsXG5cdFx0XHQnbGVuZ3RoJzogOFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2dpZCcsXG5cdFx0XHQnbGVuZ3RoJzogOFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2ZpbGVTaXplJyxcblx0XHRcdCdsZW5ndGgnOiAxMlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ210aW1lJyxcblx0XHRcdCdsZW5ndGgnOiAxMlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2NoZWNrc3VtJyxcblx0XHRcdCdsZW5ndGgnOiA4XG5cdFx0fSxcblx0XHR7XG5cdFx0XHQnZmllbGQnOiAndHlwZScsXG5cdFx0XHQnbGVuZ3RoJzogMVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2xpbmtOYW1lJyxcblx0XHRcdCdsZW5ndGgnOiAxMDBcblx0XHR9LFxuXHRcdHtcblx0XHRcdCdmaWVsZCc6ICd1c3RhcicsXG5cdFx0XHQnbGVuZ3RoJzogOFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ293bmVyJyxcblx0XHRcdCdsZW5ndGgnOiAzMlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ2dyb3VwJyxcblx0XHRcdCdsZW5ndGgnOiAzMlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J2ZpZWxkJzogJ21ham9yTnVtYmVyJyxcblx0XHRcdCdsZW5ndGgnOiA4XG5cdFx0fSxcblx0XHR7XG5cdFx0XHQnZmllbGQnOiAnbWlub3JOdW1iZXInLFxuXHRcdFx0J2xlbmd0aCc6IDhcblx0XHR9LFxuXHRcdHtcblx0XHRcdCdmaWVsZCc6ICdmaWxlbmFtZVByZWZpeCcsXG5cdFx0XHQnbGVuZ3RoJzogMTU1XG5cdFx0fSxcblx0XHR7XG5cdFx0XHQnZmllbGQnOiAncGFkZGluZycsXG5cdFx0XHQnbGVuZ3RoJzogMTJcblx0XHR9XG5cdF07XG5cblx0ZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGRhdGEsIGNiKSB7XG5cdFx0dmFyIGJ1ZmZlciA9IHV0aWxzLmNsZWFuKDUxMiksXG5cdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0aGVhZGVyRm9ybWF0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR2YXIgc3RyID0gZGF0YVt2YWx1ZS5maWVsZF0gfHwgXCJcIixcblx0XHRcdFx0aSwgbGVuZ3RoO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0YnVmZmVyW29mZnNldF0gPSBzdHIuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0b2Zmc2V0ICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdG9mZnNldCArPSB2YWx1ZS5sZW5ndGggLSBpOyAvLyBzcGFjZSBpdCBvdXQgd2l0aCBudWxsc1xuXHRcdH0pO1xuXG5cdFx0aWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGNiKGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMuc3RydWN0dXJlID0gaGVhZGVyRm9ybWF0O1xuXHRtb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRIZWFkZXI7XG59KCkpO1xuIiwiLypcbiAqIHRhci1qc1xuICogTUlUIChjKSAyMDExIFQuIEphbWVzb24gTGl0dGxlXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGhlYWRlciA9IHJlcXVpcmUoXCIuL2hlYWRlclwiKSxcblx0XHR1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLFxuXHRcdHJlY29yZFNpemUgPSA1MTIsXG5cdFx0YmxvY2tTaXplO1xuXHRcblx0ZnVuY3Rpb24gVGFyKHJlY29yZHNQZXJCbG9jaykge1xuXHRcdHRoaXMud3JpdHRlbiA9IDA7XG5cdFx0YmxvY2tTaXplID0gKHJlY29yZHNQZXJCbG9jayB8fCAyMCkgKiByZWNvcmRTaXplO1xuXHRcdHRoaXMub3V0ID0gdXRpbHMuY2xlYW4oYmxvY2tTaXplKTtcblx0fVxuXG5cdFRhci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGZpbGVwYXRoLCBpbnB1dCwgb3B0cywgY2FsbGJhY2spIHtcblx0XHR2YXIgZGF0YSxcblx0XHRcdGNoZWNrc3VtLFxuXHRcdFx0bW9kZSxcblx0XHRcdG10aW1lLFxuXHRcdFx0dWlkLFxuXHRcdFx0Z2lkLFxuXHRcdFx0aGVhZGVyQXJyO1xuXG5cdFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlucHV0ID0gdXRpbHMuc3RyaW5nVG9VaW50OChpbnB1dCk7XG5cdFx0fSBlbHNlIGlmIChpbnB1dC5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIGlucHV0IHR5cGUuIFlvdSBnYXZlIG1lOiAnICsgaW5wdXQuY29uc3RydWN0b3IudG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb25cXHMqKFskQS1aYS16X11bMC05QS1aYS16X10qKVxccypcXCgvKVsxXTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0gb3B0cztcblx0XHRcdG9wdHMgPSB7fTtcblx0XHR9XG5cblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblxuXHRcdG1vZGUgPSBvcHRzLm1vZGUgfHwgcGFyc2VJbnQoJzc3NycsIDgpICYgMHhmZmY7XG5cdFx0bXRpbWUgPSBvcHRzLm10aW1lIHx8IE1hdGguZmxvb3IoK25ldyBEYXRlKCkgLyAxMDAwKTtcblx0XHR1aWQgPSBvcHRzLnVpZCB8fCAwO1xuXHRcdGdpZCA9IG9wdHMuZ2lkIHx8IDA7XG5cblx0XHRkYXRhID0ge1xuXHRcdFx0ZmlsZU5hbWU6IGZpbGVwYXRoLFxuXHRcdFx0ZmlsZU1vZGU6IHV0aWxzLnBhZChtb2RlLCA3KSxcblx0XHRcdHVpZDogdXRpbHMucGFkKHVpZCwgNyksXG5cdFx0XHRnaWQ6IHV0aWxzLnBhZChnaWQsIDcpLFxuXHRcdFx0ZmlsZVNpemU6IHV0aWxzLnBhZChpbnB1dC5sZW5ndGgsIDExKSxcblx0XHRcdG10aW1lOiB1dGlscy5wYWQobXRpbWUsIDExKSxcblx0XHRcdGNoZWNrc3VtOiAnICAgICAgICAnLFxuXHRcdFx0dHlwZTogJzAnLCAvLyBqdXN0IGEgZmlsZVxuXHRcdFx0dXN0YXI6ICd1c3RhciAgJyxcblx0XHRcdG93bmVyOiBvcHRzLm93bmVyIHx8ICcnLFxuXHRcdFx0Z3JvdXA6IG9wdHMuZ3JvdXAgfHwgJydcblx0XHR9O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBjaGVja3N1bVxuXHRcdGNoZWNrc3VtID0gMDtcblx0XHRPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHZhciBpLCB2YWx1ZSA9IGRhdGFba2V5XSwgbGVuZ3RoO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRjaGVja3N1bSArPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZGF0YS5jaGVja3N1bSA9IHV0aWxzLnBhZChjaGVja3N1bSwgNikgKyBcIlxcdTAwMDAgXCI7XG5cblx0XHRoZWFkZXJBcnIgPSBoZWFkZXIuZm9ybWF0KGRhdGEpO1xuXG5cdFx0dmFyIGksIG9mZnNldCwgbGVuZ3RoO1xuXG5cdFx0dGhpcy5vdXQuc2V0KGhlYWRlckFyciwgdGhpcy53cml0dGVuKTtcblxuXHRcdHRoaXMud3JpdHRlbiArPSBoZWFkZXJBcnIubGVuZ3RoO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBpbiB0aGlzLm91dCwgd2UgbmVlZCB0byBleHBhbmQgaXQgdG9cblx0XHQvLyBmaXQgdGhlIG5ldyBpbnB1dC5cblx0XHRpZiAodGhpcy53cml0dGVuICsgaW5wdXQubGVuZ3RoID4gdGhpcy5vdXQubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLm91dCA9IHV0aWxzLmV4dGVuZCh0aGlzLm91dCwgdGhpcy53cml0dGVuLCBpbnB1dC5sZW5ndGgsIGJsb2NrU2l6ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vdXQuc2V0KGlucHV0LCB0aGlzLndyaXR0ZW4pO1xuXG5cdFx0Ly8gdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgcmVjb3JkU2l6ZVxuXHRcdHRoaXMud3JpdHRlbiArPSBpbnB1dC5sZW5ndGggKyAocmVjb3JkU2l6ZSAtIChpbnB1dC5sZW5ndGggJSByZWNvcmRTaXplIHx8IHJlY29yZFNpemUpKTtcblxuXHRcdC8vIG1ha2Ugc3VyZSB0aGVyZSdzIGF0IGxlYXN0IDIgZW1wdHkgcmVjb3JkcyB3b3J0aCBvZiBleHRyYSBzcGFjZVxuXHRcdGlmICh0aGlzLm91dC5sZW5ndGggLSB0aGlzLndyaXR0ZW4gPCByZWNvcmRTaXplICogMikge1xuXHRcdFx0dGhpcy5vdXQgPSB1dGlscy5leHRlbmQodGhpcy5vdXQsIHRoaXMud3JpdHRlbiwgcmVjb3JkU2l6ZSAqIDIsIGJsb2NrU2l6ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5vdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm91dDtcblx0fTtcblxuXHRUYXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMud3JpdHRlbiA9IDA7XG5cdFx0dGhpcy5vdXQgPSB1dGlscy5jbGVhbihibG9ja1NpemUpO1xuXHR9O1xuXG4gIFRhci51dGlscyA9IHV0aWxzO1xuXG5cdFRhci5zdHJpbmdUb1VpbnQ4ID0gdXRpbHMuc3RyaW5nVG9VaW50ODtcblx0VGFyLnVpbnQ4VG9CYXNlNjQgPSB1dGlscy51aW50OFRvQmFzZTY0O1xuICBUYXIuYmFzZTY0VG9VaW50OCA9IHV0aWxzLmJhc2U2NFRvVWludDg7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IFRhcjtcbn0oKSk7XG4iLCIvKlxuICogdGFyLWpzXG4gKiBNSVQgKGMpIDIwMTEgVC4gSmFtZXNvbiBMaXR0bGVcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgbG9va3VwID0gW1xuXHRcdFx0J0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsXG5cdFx0XHQnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJyxcblx0XHRcdCdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLFxuXHRcdFx0J1knLCAnWicsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsXG5cdFx0XHQnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJyxcblx0XHRcdCdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLFxuXHRcdFx0J3cnLCAneCcsICd5JywgJ3onLCAnMCcsICcxJywgJzInLCAnMycsXG5cdFx0XHQnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnKycsICcvJ1xuXHRcdF07XG5cdGZ1bmN0aW9uIGNsZWFuKGxlbmd0aCkge1xuXHRcdHZhciBpLCBidWZmZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0YnVmZmVyW2ldID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChvcmlnLCBsZW5ndGgsIGFkZExlbmd0aCwgbXVsdGlwbGVPZikge1xuXHRcdHZhciBuZXdTaXplID0gbGVuZ3RoICsgYWRkTGVuZ3RoLFxuXHRcdFx0YnVmZmVyID0gY2xlYW4oKHBhcnNlSW50KG5ld1NpemUgLyBtdWx0aXBsZU9mKSArIDEpICogbXVsdGlwbGVPZik7XG5cblx0XHRidWZmZXIuc2V0KG9yaWcpO1xuXG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhZChudW0sIGJ5dGVzLCBiYXNlKSB7XG5cdFx0bnVtID0gbnVtLnRvU3RyaW5nKGJhc2UgfHwgOCk7XG5cdFx0cmV0dXJuIFwiMDAwMDAwMDAwMDAwXCIuc3Vic3RyKG51bS5sZW5ndGggKyAxMiAtIGJ5dGVzKSArIG51bTtcblx0fVx0XG5cdFxuXHRmdW5jdGlvbiBzdHJpbmdUb1VpbnQ4IChpbnB1dCwgb3V0LCBvZmZzZXQpIHtcblx0XHR2YXIgaSwgbGVuZ3RoO1xuXG5cdFx0b3V0ID0gb3V0IHx8IGNsZWFuKGlucHV0Lmxlbmd0aCk7XG5cblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0b3V0W29mZnNldF0gPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0b2Zmc2V0ICs9IDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyB0aGlzIHByZXZlbnRzIGFuIEVSUl9JTlZBTElEX1VSTCBpbiBDaHJvbWUgKEZpcmVmb3ggb2theSlcblx0XHRzd2l0Y2ggKG91dHB1dC5sZW5ndGggJSA0KSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdG91dHB1dCArPSAnPSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0VG9VaW50OChpbnB1dCkge1xuXHRcdHZhciBiYXNlNjQgPSBpbnB1dC5tYXRjaCgvXihbXj1dKykvKVsxXSxcblx0XHRcdGV4dHJhQnl0ZXMgPSBpbnB1dC5tYXRjaCgvKD0qKSQvKVsxXS5sZW5ndGgsXG5cdFx0XHRpID0gMCwgbGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCwgdGVtcCwgb2Zmc2V0ID0gMCxcblx0XHRcdHJldCA9IGNsZWFuKGJhc2U2NC5sZW5ndGggKiAuNzUgKyBleHRyYUJ5dGVzKTtcblxuXHRcdHdoaWxlIChpIDwgbGVuZ3RoKSB7XG5cdFx0XHR0ZW1wID0gMDtcblxuXHRcdFx0dGVtcCB8PSBsb29rdXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpIHx8ICdBJykgPDwgMTg7XG5cdFx0XHRpICs9IDE7XG5cdFx0XHR0ZW1wIHw9IGxvb2t1cC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkgfHwgJ0EnKSA8PCAxMjtcblx0XHRcdGkgKz0gMTtcblx0XHRcdHRlbXAgfD0gbG9va3VwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpKSB8fCAnQScpIDw8IDY7XG5cdFx0XHRpICs9IDE7XG5cdFx0XHR0ZW1wIHw9IGxvb2t1cC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkgfHwgJ0EnKTtcblx0XHRcdGkgKz0gMTtcblxuXHRcdFx0cmV0W29mZnNldF0gPSB0ZW1wID4+IDE2ICYgMHhGRjtcblx0XHRcdG9mZnNldCArPSAxO1xuXHRcdFx0cmV0W29mZnNldF0gPSB0ZW1wID4+IDggJiAweEZGO1xuXHRcdFx0b2Zmc2V0ICs9IDE7XG5cdFx0XHRyZXRbb2Zmc2V0XSA9IHRlbXAgJiAweEZGO1xuXHRcdFx0b2Zmc2V0ICs9IDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5cdG1vZHVsZS5leHBvcnRzLnBhZCA9IHBhZDtcblx0bW9kdWxlLmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuXHRtb2R1bGUuZXhwb3J0cy5zdHJpbmdUb1VpbnQ4ID0gc3RyaW5nVG9VaW50ODtcblx0bW9kdWxlLmV4cG9ydHMudWludDhUb0Jhc2U2NCA9IHVpbnQ4VG9CYXNlNjQ7XG5cdG1vZHVsZS5leHBvcnRzLmJhc2U2NFRvVWludDggPSBiYXNlNjRUb1VpbnQ4O1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkb21haW4gPSAnd3d3LnRha2FyYXRvbXkuY28uanAnXG5jb25zdCBUYXIgPSByZXF1aXJlKCd0YXItanMnKVxuXG4vKiB1dGlscyAqL1xuY29uc3QgdG9BcnIgPSBvYmogPT4ge1xuICBpZiAoIW9iaikgcmV0dXJuIFtdXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgcmV0dXJuIFtdXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosMClcbn1cbmNvbnN0ICRmZXRjaCA9ICguLi5hcmcpID0+IHtcbiAgcmV0dXJuIGZldGNoKGFyZykudGhlbihyZXMgPT4ge1xuICAgIGlmIChyZXMub2spIHJldHVybiByZXNcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzKVxuICB9KVxufVxuY29uc3Qgc3RyaW5nVG9VaW50OCA9IHN0ciA9PiB7XG4gIHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShzdHIpXG59XG5cbi8qIHBhcnNlciAqL1xuZnVuY3Rpb24gdG9DYXJkVHlwZShzdHIpIHtcbiAgbGV0IG1hcCA9IHtcbiAgICAn44Or44Oq44KwJzogJ0xSSUcnLFxuICAgICfjgqLjg7zjg4QnOiAnQVJUUycsXG4gICAgJ+OCt+OCsOODiyc6ICdTSUdOSScsXG4gICAgJ+OCueODmuODqyc6ICdTUEVMTCcsXG4gIH1cbiAgcmV0dXJuIG1hcFtzdHJdIHx8IHN0clxufVxuZnVuY3Rpb24gdG9Db2xvcihzdHIpIHtcbiAgbGV0IG1hcCA9IHtcbiAgICAn55m9JzogJ1dISVRFJyxcbiAgICAn6buSJzogJ0JMQUNLJyxcbiAgICAn6LWkJzogJ1JFRCcsXG4gICAgJ+mdkic6ICdCTFVFJyxcbiAgICAn57eRJzogJ0dSRUVOJyxcbiAgICAn54ShJzogJ0NPTE9STEVTUycsXG4gIH1cbiAgcmV0dXJuIG1hcFtzdHJdIHx8IHN0clxufVxuZnVuY3Rpb24gdG9DYXJkVGV4dChlbCkge1xuICBsZXQgdGV4dCA9IHRvQXJyKGVsLmNoaWxkTm9kZXMpLm1hcChub2RlID0+IHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9eXFxzKy8sJycpLnJlcGxhY2UoL1xccyskLywnJylcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgICByZXR1cm4gbm9kZS5hbHRcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgIHJldHVybiAnXFxuJ1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50ZXh0Q29udGVudFxuICB9KS5qb2luKCcnKVxuICByZXR1cm4gdGV4dFxufVxuZnVuY3Rpb24gdG9GYXEoZWwpIHtcbiAgbGV0IGZhcSA9IHt9XG4gIGZhcS5xID0gZWwucXVlcnlTZWxlY3RvcignLmNhcmRfcnVsZUZBUV9xJykudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccysvLCcnKS5yZXBsYWNlKC9cXHMrJC8sJycpXG4gIGZhcS5hID0gZWwucXVlcnlTZWxlY3RvcignLmNhcmRfcnVsZUZBUV9hJykudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccysvLCcnKS5yZXBsYWNlKC9cXHMrJC8sJycpXG4gIHJldHVybiBmYXFcbn1cblxuXG5mdW5jdGlvbiB0b0luZm8oZG9jLCBpZCkge1xuICBsZXQgaW5mbyA9IHt9XG4gIGluZm8ucGlkID0gaWQgfHwgZG9jLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkX2RldGFpbF90aXRsZSA+IHAnKS50ZXh0Q29udGVudFxuICBpbmZvLnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgaW5mby53eGlkID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkX2RldGFpbF90aXRsZSA+IHAnKS50ZXh0Q29udGVudFxuICBpbmZvLm5hbWUgPSBkb2MucXVlcnlTZWxlY3RvcignLmNhcmRfZGV0YWlsX3RpdGxlID4gaDMnKS5maXJzdENoaWxkLnRleHRDb250ZW50XG4gIGluZm8ua2FuYSA9IGRvYy5xdWVyeVNlbGVjdG9yKCcuY2FyZF9kZXRhaWxfa2FuYScpLnRleHRDb250ZW50LnNsaWNlKDEsLTEpXG4gIGluZm8ucmFyaXR5ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkX3Jhcml0eScpLnRleHRDb250ZW50LnJlcGxhY2UoL1xccy9nLCcnKVxuXG4gIGxldCB0cnMgPSBkb2MucXVlcnlTZWxlY3RvckFsbCgnLmNhcmRfZGF0ZV9ib3ggdHInKVxuICAvLyBpbmZvLmNhcmRUeXBlID0gdG9DYXJkVHlwZSh0cnNbMF0uY2hpbGRyZW5bMV0udGV4dENvbnRlbnQpXG4gIGluZm8uY2FyZFR5cGUgPSB0cnNbMF0uY2hpbGRyZW5bMV0udGV4dENvbnRlbnRcbiAgaW5mby5jbGFzcyA9IHRyc1swXS5jaGlsZHJlblszXS50ZXh0Q29udGVudFxuICAvLyBpbmZvLmNvbG9yID0gdG9Db2xvcih0cnNbMV0uY2hpbGRyZW5bMV0udGV4dENvbnRlbnQpXG4gIGluZm8uY29sb3IgPSB0cnNbMV0uY2hpbGRyZW5bMV0udGV4dENvbnRlbnRcbiAgaW5mby5sZXZlbCA9IHRyc1sxXS5jaGlsZHJlblszXS50ZXh0Q29udGVudFxuICBpbmZvLmdyb3dDb3N0ID0gdHJzWzJdLmNoaWxkcmVuWzFdLnRleHRDb250ZW50XG4gIGluZm8uY29zdCA9IHRyc1syXS5jaGlsZHJlblszXS50ZXh0Q29udGVudFxuICBpbmZvLmxpbWl0ID0gdHJzWzNdLmNoaWxkcmVuWzFdLnRleHRDb250ZW50XG4gIGluZm8ucG93ZXIgPSB0cnNbM10uY2hpbGRyZW5bM10udGV4dENvbnRlbnRcbiAgaW5mby5saW1pdGluZyA9IHRyc1s0XS5jaGlsZHJlblsxXS50ZXh0Q29udGVudFxuXG4gIC8vIGd1YXJkLCBsaW1pdGluZyBvciBjb2luXG4gIGxldCBrZXkgPSB0cnNbNF0uY2hpbGRyZW5bMl0udGV4dENvbnRlbnRcbiAgbGV0IHZhbHVlID0gdHJzWzRdLmNoaWxkcmVuWzNdLnRleHRDb250ZW50XG4gIGlmIChrZXkgPT09ICfjgqzjg7zjg4knKSB7XG4gICAgaW5mby5ndWFyZCA9IHZhbHVlXG4gICAgaW5mby50aW1pbmcgPSAnLSdcbiAgfSBlbHNlIGlmIChrZXkgPT09ICfkvb/nlKjjgr/jgqTjg5/jg7PjgrAnKSB7XG4gICAgaW5mby5ndWFyZCA9ICctJ1xuICAgIGluZm8udGltaW5nID0gdmFsdWVcbiAgfSBlbHNlIGlmIChrZXkgPT09ICfjgrPjgqTjg7MnKSB7XG4gICAgaW5mby5ndWFyZCA9ICctJ1xuICAgIGluZm8udGltaW5nID0gJy0nXG4gICAgaW5mby5jb2luID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oYCR7aW5mby5waWR9OiB1bmtub3duIGtleSBcIiR7a2V5fVwiIWApXG4gIH1cblxuICBsZXQgZWwgPSBkb2MucXVlcnlTZWxlY3RvcignLmNhcmRfc2tpbGwnKVxuICBpbmZvLmNhcmRTa2lsbCA9IGVsPyB0b0NhcmRUZXh0KGVsKSA6ICcnXG5cbiAgaW5mby5jYXJkVGV4dHMgPSB0b0Fycihkb2MucXVlcnlTZWxlY3RvckFsbCgnLmNhcmRfdGV4dDpub3QoLmNhcmRfc2tpbGwpJykpLm1hcCh0b0NhcmRUZXh0KVxuXG4gIC8vIGluZm8uaW1nVXJsID0gZG9tYWluICsgZG9jLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkX2ltZyA+IGltZycpLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgaW5mby5pbWdVcmwgPSBkb2MucXVlcnlTZWxlY3RvcignLmNhcmRfaW1nID4gaW1nJykuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICBpbmZvLmlsbHVzdCA9IChkb2MucXVlcnlTZWxlY3RvcignLmNhcmRfaW1nJykudGV4dENvbnRlbnQubWF0Y2goL0lsbHVzdCAoLiopJC8pIHx8IFtdKVsxXSB8fCAnJ1xuICBpZiAoIWluZm8uaWxsdXN0KSBjb25zb2xlLndhcm4oYCR7aW5mby5waWR9OiBubyBpbGx1c3QhYClcblxuICBpbmZvLmZhcXMgPSB0b0Fycihkb2MucXVlcnlTZWxlY3RvckFsbCgnLmNhcmRfRkFRID4gcCcpKS5tYXAodG9GYXEpXG5cbiAgcmV0dXJuIGluZm9cbn1cblxuLyogZmV0Y2ggKi9cbmZ1bmN0aW9uIGZldGNoQnlJZCAodGFyLCBpKSB7XG4gIGxldCB1cmwgPSBgaHR0cDovLyR7ZG9tYWlufS9wcm9kdWN0cy93aXhvc3MvY2FyZC9jYXJkX2RldGFpbC5waHA/Y2FyZF9pZD0ke2l9YFxuICByZXR1cm4gZmV0Y2hCeVVybCh0YXIsIHVybCwgaSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hCeVdYSWQodGFyLCB3eF9pZCkge1xuICBsZXQgdXJsID0gYGh0dHA6Ly8ke2RvbWFpbn0vcHJvZHVjdHMvd2l4b3NzL2NhcmQvY2FyZF9saXN0LnBocD9jYXJkPWNhcmRfZGV0YWlsJmNhcmRfbm89JHt3eF9pZH1gXG4gIHJldHVybiBmZXRjaEJ5VXJsKHRhciwgdXJsLCB1bmRlZmluZWQpXG59XG5cbmZ1bmN0aW9uIGZldGNoQnlVcmwodGFyLCB1cmwsIGkpIHtcbiAgcmV0dXJuICRmZXRjaCh1cmwpXG4gIC50aGVuKHJlcyA9PiByZXMudGV4dCgpKVxuICAudGhlbihodG1sID0+IHtcbiAgICBsZXQgZG9tID0gKG5ldyBET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKGh0bWwsJ3RleHQvaHRtbCcpXG4gICAgaWYgKCFkb20pIHRocm93ICdGYWlsZWQgdG8gcGFyc2UgRE9NISdcblxuICAgIC8vIGpzb25cbiAgICBsZXQgaW5mbyA9IHRvSW5mbyhkb20sIGkpXG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShpbmZvLCBudWxsLCAnXFx0JylcbiAgICBsZXQgbmFtZSA9ICgnMDAwJyArIGkpLnNsaWNlKC00KSArICdfJyArIGluZm8ud3hpZFxuICAgIHRhci5hcHBlbmQoYCR7bmFtZX0uanNvbmAsIHN0cmluZ1RvVWludDgoanNvbikpXG4gICAgY29uc29sZS5sb2coYCR7bmFtZX0uanNvbiBkb25lIWApXG5cbiAgICAvLyBodG1sXG4gICAgaHRtbCA9IGh0bWwucmVwbGFjZSgnPGhlYWQ+JywnPGhlYWQ+XFxyXFxuPGJhc2UgaHJlZj1cImh0dHA6Ly93d3cudGFrYXJhdG9teS5jby5qcC9cIiAvPicpXG4gICAgdGFyLmFwcGVuZChgJHtuYW1lfS5odG1sYCwgc3RyaW5nVG9VaW50OChodG1sKSlcbiAgICBjb25zb2xlLmxvZyhgJHtuYW1lfS5odG1sIGRvbmUhYClcblxuICAgIC8vIGltYWdlXG4gICAgcmV0dXJuICRmZXRjaChpbmZvLmltZ1VybClcbiAgICAudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG4gICAgLnRoZW4oYnVmZmVyID0+IHtcbiAgICAgIHRhci5hcHBlbmQoYCR7bmFtZX0uanBnYCwgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSlcbiAgICAgIGNvbnNvbGUubG9nKGAke25hbWV9LmpwZyBkb25lIWApXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hSYW5nZShtaW4sIG1heCkge1xuICBsZXQgdGFyID0gbmV3IFRhcigpXG4gIGxldCBwcm9taXNlcyA9IFtdXG4gIGZvciAobGV0IGkgPSBtaW47IGkgPD0gbWF4OyBpKyspIHtcbiAgICBwcm9taXNlcy5wdXNoKGZldGNoQnlJZCh0YXIsIGkpKVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgLnRoZW4oKCkgPT4ge1xuICAgIGxldCBuYW1lID0gKCcwMDAnICsgbWluKS5zbGljZSgtNCkgKyAnLScgKyAoJzAwMCcgKyBtYXgpLnNsaWNlKC00KVxuICAgIGRvd25sb2FkVGFyKHRhciwgbmFtZSlcbiAgfSlcbn1cblxuLy8gZmV0Y2hXWEJveChcIldESzAyXCIsIDEsIDIwKVxuZnVuY3Rpb24gZmV0Y2hXWEJveChwcmVmaXgsIG1pbiwgbWF4KSB7XG4gIGxldCB0YXIgPSBuZXcgVGFyKClcbiAgbGV0IHByb21pc2VzID0gW11cbiAgZm9yIChsZXQgaSA9IG1pbjsgaSA8PSBtYXg7IGkgKyspIHtcbiAgICBjb25zdCB3eF9pZCA9IGAke3ByZWZpeH0tJHsoJzAwJyArIGkpLnNsaWNlKC0zKX1gO1xuICAgIHByb21pc2VzLnB1c2goZmV0Y2hCeVdYSWQodGFyLCB3eF9pZCkpXG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAudGhlbigoKSA9PiB7XG4gICAgbGV0IG5hbWUgPSAoJzAwMCcgKyBtaW4pLnNsaWNlKC00KSArICctJyArICgnMDAwJyArIG1heCkuc2xpY2UoLTQpXG4gICAgZG93bmxvYWRUYXIodGFyLCBuYW1lKVxuICB9KVxufVxuXG5mdW5jdGlvbiBkb3dubG9hZFRhcih0YXIsIG5hbWUpIHtcbiAgbGV0IGJsb2IgPSBuZXcgQmxvYihbdGFyLm91dF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSlcbiAgbGV0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgbGluay5ocmVmID0gdXJsXG4gIGxpbmsuZG93bmxvYWQgPSBgJHtuYW1lfS50YXJgXG4gIGxpbmsuY2xpY2soKVxufVxuXG53aW5kb3cuZmV0Y2hSYW5nZSA9IGZldGNoUmFuZ2VcbndpbmRvdy5mZXRjaFdYQm94ID0gZmV0Y2hXWEJveFxuIl19"}